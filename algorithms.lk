
(def max-container-size (expt 2 48))

(def leo
  (withs (leo-seq (afn (a b) (seq a (self b (+ a b 1))))
          v       (seq->vector (seq-first-that (leo-seq 1 1)
                                               (less-than max-container-size))))
    (fn (i)
      (vector-ref v i))))

(macro (leo-normilize p n)
  `(while (= (bitwise-and ,p 1) 0)
     (set ,p (>> ,p 1))
     (set ,n (+ ,n 1))))

(def (vector-smoothsort sort v)
  (with (lt (fn (i j) (< (vector-ref v i)
                        (vector-ref v j)))
         swap (fn (i j) (let tmp (vector-ref v i)
                          (vector-set v i (vector-ref v j))
                          (vector-set v j tmp)))
         N (vector-size v))
    (withs (sift (afn (top n)
                   (when (> n 1)
                     (let child (- top (leo (- n 2)) 1)
                       (when (lt child (- top 1))
                         (set child (- top 1))
                         (set n (- n 1)))
                       (when (lt top child)
                         (swap top child)
                         (self child (- n 1))))))
            trinkle (afn (top p n)
                      (when (> p 0)
                        (leo-normilize p n)
                        (let ntop (- top (leo n))
                          (if (or (= p 1) (lt ntop top)) (sift top n)
                              (< n 2) (do (swap ntop top)
                                          (self ntop (- p 1) n))
                                      (with (child (+ ntop (leo (- n 1)))
                                             nn    n)
                                        (when (lt child (- top 1))
                                          (set child (- top 1))
                                          (set nn (- nn 1)))
                                        (if (lt child ntop)
                                            (do (swap ntop top)
                                                (self ntop (- p 1) n))
                                            (do (swap child top)
                                                (sift child (- nn 1)))))))))
            semitrinkle (fn (top p n)
                          (let ntop (- top (leo n))
                            (when (and (> p 1) (lt top ntop))
                              (swap ntop top)
                              (trinkle ntop (- p 1) n))))
            sort (afn (i p n)
                   (when (> i 1)
                     (set p (- p 1))
                     (if (< n 2)
                         (do (leo-normilize p n)
                             (self (- i 1) p n))
                         (do (semitrinkle (- i (leo (- n 2)) 2) (+ (<< p 1) 1) (- n 1))
                             (semitrinkle (- i 2)               (+ (<< p 2) 3) (- n 2))
                             (self (- i 1) (+ (<< p 2) 3) (- n 2)))))))
      ((afn (i p n)
         (if (< i N)
           (if (= (bitwise-and p 2) 2)
               (do (sift (- i 1) n)
                   (self (+ i 1) (+ (>> p 2) 1) (+ n 2)))
               (do (if (< (+ i (leo (- n 1))) N)
                       (sift (- i 1) n)
                       (trinkle (- i 1) p n))
                   (if (< n 2)
                     (self (+ i 1) (<< p 1) 0)
                     (self (+ i 1) (+ (<< p (- n 1)) 1) 1))))
           (do (trinkle (- N 1) (bitwise-or p 1) n)
               (sort N p n))))
       3 1 2))))

(def (vector-lower-bound v start end x)
  (if (< start end)
      (let m (div (+ start end) 2)
        (if (<= x (vector-ref v m))
            (vector-lower-bound v start m x)
            (vector-lower-bound v (+ m 1) end x)))
      start))

(def (vector-upper-bound v start end x)
  (if (< start end)
      (let m (div (+ start end) 2)
        (if (< x (vector-ref v m))
            (vector-upper-bound v start m x)
            (vector-upper-bound v (+ m 1) end x)))
      start))

(def (vector-insertsort v)
  (with (insert (afn (i end x)
                  (if (< i end)
                      (do (vector-set v end (vector-ref v (- end 1)))
                          (self i (- end 1) x))
                      (vector-set v i x)))
         N (vector-size v))
    ((afn (i)
       (when (< i N)
         (withs (x (vector-ref v i)
                 ub (vector-upper-bound v 0 i x))
           (insert ub i x)
           (self (+ i 1)))))
     0)))

(def (vector-sort x)
  (if (< (length x) 150)
      (vector-insertsort x)
      (vector-smoothsort x)))

(def (sort x)
  (if (vector? x) (vector-sort x)
                  (raise 'generic-type-error)))

(def (list-sorted? l)
  (let reduce (afn (x rest)
                (or (null? rest)
                    (and (<= x (car rest))
                         (self (car rest) (cdr rest)))))
    (or (null? l) (reduce (car l) (cdr l)))))

(def (vector-sorted? v)
  (let n (- (vector-size v) 2)
    ((afn (i)
       (or (> i n)
           (and (<= (vector-ref v i) (vector-ref v (+ i 1)))
                (self (+ i 1)))))
     0)))

(def (sorted? x)
  (if (vector? x) (vector-sorted? x)
      (pair? x)   (list-sorted? x)))
