(def (scons a b) (annotate 'seq (cons a b)))

(macro (seq hd tl)
  `(scons ,hd (fn () ,tl)))

(def (seq? x) (or (null? x) (is-a x 'seq)))
(def (seq-hd s) (car (rep s)))
(def (seq-tl s)
  (let r (rep s)
    (when (proc? (cdr r))
      (set-cdr r ((cdr r))))
    (cdr r)))

(def (seq-map f s)
  (unless (null? s)
    (seq (f (seq-hd s)) (seq-map f (seq-tl s)))))

(def (map f x)
  (if (pair? x)
      (list-map f x)
      (seq-map f x)))

(def (integrate x0 + s)
  (unless (null? s)
    (seq x0 (integrate (+ x0 (seq-hd s)) + (seq-tl s)))))

(def (as-seq x)
  (if (vector? x) ((afn (i)
                     (when (< i (vector-size x))
                       (seq (vector-ref x i) (self (+ i 1)))))
                   0)
      (list? x)   ((afn (l) (unless (null? l) (seq (car l) (self (cdr l))))) x)
                  (error 'as-seq "Can't assume it's a sequence.")))

(def (list-first-n l n)
  (when (> n 0)
    (seq (car l) (list-first-n (cdr l) (- n 1)))))

(def (seq-first-n s n)
  (when (and s (> n 0))
    (seq (seq-hd s) (seq-first-n (seq-tl s) (- n 1)))))

(def (seq-nth s n)
  (if (= n 0)
      (seq-hd s)
      (seq-nth (seq-tl s) (- n 1))))

(def (seq-find-that s f)
  (unless (null? s)
    (if (f (seq-hd s))
        (seq-hd s)
        (seq-find-that (seq-tl s) f))))

(def (seq-first-that s f)
  (unless (null? s)
    (when (f (seq-hd s))
      (seq (seq-hd s) (seq-first-that (seq-tl s) f)))))

(def (first-n s n)
  (if (pair? s)
      (list-first-n s n)
      (seq-first-n s n)))

(def (list-enumerate s n)
  (unless (null? s) 
    (seq (list n (car s)) (list-enumerate (cdr s) (+ n 1)))))

(def (seq-enumerate s n)
  (unless (null? s)
    (seq (list n (seq-hd s)) (seq-enumerate (seq-tl s) (+ n 1)))))

(def (range-enumerate r n)
  ((afn (i)
     (when (< i (range-size r))
       (seq (list (+ i n) (range-ref r i)) (self (+ i 1)))))
   0))

(def (enumerate x n)
  (if (pair? x)  (list-enumerate x n)
      (seq? x)   (seq-enumerate x n)
      (range? x) (range-enumerate x n)
                 (error "Can't enumerate " x)))

(def (inf-range start stride)
  (seq start (inf-range (+ start stride) stride)))
  
(def (seq->list s)
  ((afn (r s)
     (if (null? s)
         (reverse r) 
         (self (cons (hd s) r) (tl s))))
   nil s))

(def (seq->vector s)
  (accumulate-to-vector acc
    (seq-for-each s acc)))

(def (list-for-each x f)
  (unless (null? x)
    (f (car x)) 
    (list-for-each (cdr x) f)))

(def (range a b) (annotate 'range (cons a b)))
(def (range? x) (is-a x 'range))
(def (range-from r) (car (rep r)))
(def (range-to r)   (cdr (rep r)))
(def (range-ref r i) (+ (range-from r) i))
(def (range-size r) (- (range-to r) (range-from r)))

(def (range-for-each x f)
  ((afn (i)
     (when (< i (range-to x))
       (f i)
       (self (+ i 1))))
   (range-from x)))

(def (seq-for-each s f)
  (unless (null? s)
    (f (seq-hd s))
    (seq-for-each (seq-tl s) f)))

(def (hd s) 
  (if (pair? s) 
      (car s)
      (seq-hd s)))

(def (tl s) 
  (if (pair? s)
      (cdr s)
      (seq-tl s)))

(defp seq-print-limit 3)

(def-method (write (x seq) s)
  (w/stdout s
    (print #\()
    (print-all (seq-first-n x (seq-print-limit)))
    (print " ...)")))
