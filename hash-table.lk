(def (make-hash-table) (annotate 'hash-table (cons 0 (make-vector 0))))
(def (hash-table? x) (is-a x 'hash-table))
(def (hash-table-size ht) (car (rep ht)))
(def (hash-table-data ht) (cdr (rep ht)))
(def (hash-table-set-size ht n) (set (car (rep ht)) n))
(def (hash-table-set-data ht d) (set (cdr (rep ht)) d))
(add-place-setter 'hash-table-size 'hash-table-set-size)
(add-place-setter 'hash-table-data 'hash-table-set-data)

(def (hash-table-empty? ht)
  (= (hash-table-size ht) 0))

(def (hash-table-threshold-capacity ht)
  (* (vector-size (hash-table-data ht)) 4/3))

(def (hash-table-ref ht key &opt defval)
  (if (hash-table-empty? ht)
      defval
      (withs (tbl (hash-table-data ht)
              i   (mod (hash key) (vector-size tbl)))
        (if-let e (assoc (vector-ref tbl i) key)
          (cdr e)
          defval))))

(def (hash-table-for-each ht f)
  (vector-for-each (hash-table-data ht)
    (fn (bucket)
      (list-for-each bucket
        (fn (e) (f (car e) (cdr e)))))))

(def (hash-table-grow ht)
  (withs (n       (max (* (hash-table-size ht) 2) 1)
          new-tbl (make-vector n))
    (hash-table-for-each ht
      (fn (key value)
        (let i (mod (hash key) n)
          (push (cons key value) (vector-ref new-tbl i)))))
    (set (hash-table-data ht) new-tbl)
    none))

(def (hash-table-set ht key value)
  (if (> (+ (hash-table-size ht) 1) (hash-table-threshold-capacity ht))
    (hash-table-grow ht))
  (withs (tbl (hash-table-data ht)
          i   (mod (hash key) (vector-size tbl)))
    (if-let e (assoc (vector-ref tbl i) key)
      (set (cdr e) value)
      (do (push (cons key value) (vector-ref tbl i))
          (inc (hash-table-size ht))))))

;(def (hash-table-bucket-stats ht)
;  (let m (make-hash-table)
;    (for x (hash-table-data ht)
;      (let n (list-length x)
;        (hash-table-set m n (+ (hash-table-ref m n 0) 1))))
;    m))

(macro (accumulate-to-hash-table acc-fn &rest body)
  (w/uniq (ght)
    `(withs (,ght (make-hash-table)
             ,acc-fn (fn (k v) (hash-table-set ,ght k v)))
       ,@body
       ,ght)))

(def (hash-table &rest contents)
  (accumulate-to-hash-table acc
    ((afn (xs)
       (if (null? xs)       nil
           (null? (cdr xs)) (acc (car xs) nil)
                            (do (acc (car xs) (cadr xs))
                                (self (cddr xs)))))
      contents)))

(def (alist->hash-table x)
  (accumulate-to-hash-table acc
    (alist-for-each x (fn (k v) (acc k v)))))

(def-method (serialize (x hash-table) p)
  (with-output-to p
    (w/padding pd #\space
      (print #\{)
      (hash-table-for-each x (fn (key value) (print pd (repr key) pd (repr value))))
      (print #\}))))

(def-method (for-each (x hash-table) f) (hash-table-for-each x f))

; Switching to hash-table in setters storage.
(unless (hash-table? place-setters)
  (set place-setters (alist->hash-table place-setters)))

(def (place-setter getter-name)
  (hash-table-ref place-setters getter-name))

(def (add-place-setter getter-name setter-name)
  (hash-table-set place-setters getter-name setter-name))

(add-place-setter 'hash-table-ref 'hash-table-set)

; Switching to hash-table in modules registry
(set loaded-modules (alist->hash-table loaded-modules))
(def (loaded? path) (hash-table-ref loaded-modules path))
(def (register-module path) (hash-table-set loaded-modules path true))
