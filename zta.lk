(set list (fn xs xs))

(set macro
  (annotate 'macro
            (fn (sig . body)
              `(set ,(car sig)
                    (annotate 'macro (fn ,(cdr sig) ,@body))))))

(macro (def sig . body)
  (if (symbol? sig)
      `(set ,sig ,@body)
      `(set ,(car sig) (fn ,(cdr sig) ,@body))))

(def (cadr x) (car (cdr x)))
(def (cddr x) (cdr (cdr x)))

(def (null? x) (is x nil))
(def (not x) (is x nil))
(def (no x) (is x nil))

(macro (rfn sig . body)
  ((fn (name params)
     `((fn (,name)
         (set ,name (fn ,params ,@body))
         ,name)
       nil))
   (car sig) (cdr sig)))

(macro (afn params . body)
  `(rfn (self ,@params) ,@body))

(def (list-length xs)
  ((afn (n xs)
     (if (null? xs)
         n
         (self (+ n 1) (cdr xs))))
   0 xs))

(def (reverse xs)
  ((afn (rs xs)
     (if (null? xs)
         rs
         (self (cons (car xs) rs) (cdr xs))))
   nil xs))

(def (pair xs)
  ((afn (ps xs)
     (if (null? xs)       (reverse ps)
         (null? (cdr xs)) (self (cons (list (car xs)) ps) nil)
                          (self (cons (list (car xs) (cadr xs)) ps) (cddr xs))))
   nil xs))

(def (intersperse xs ys)
  (if (null? xs)
      ys
      (cons (car xs) (intersperse ys (cdr xs)))))

(def (map f xs)
  ((afn (rs xs)
     (if (null? xs)
         (reverse rs)
         (self (cons (f (car xs)) rs) (cdr xs))))
   nil xs))

(macro (let bindings . body)
  ((fn (paired-bindings)
     `((fn ,(map car paired-bindings) ,@body) ,@(map cadr paired-bindings)))
   (pair bindings)))

(macro (w/uniq names . body)
  `(let ,(intersperse names (map (fn (_) '(gensym)) names))
     ,@body))

(macro (and . args)
  (if (null? args)       'true
      (null? (cdr args)) (car args)
                         `(if ,(car args) (and ,@(cdr args)))))

; BUG in macro expansion: adding ,@(cdr args) triggers (declare (special nil))
(macro (or . args)
  (if (null? args)
      'false
      (w/uniq (g)
        `(let (,g ,(car args))
           (if ,g ,g ,@(cdr args))))))

(macro (aand x . args)
  `(let (it ,x)
     (and it ,@args)))

(macro (after x . body)
  (w/uniq (g)
    `(let (,g ,x) ,@body ,g)))

(macro (do . body)
  `((fn () ,@body)))

(macro (when cnd . body)
  `(if ,cnd (do ,@body)))

(macro (unless cnd . body)
  `(if (not ,cnd) (do ,@body)))

(macro (while cnd . body)
  (w/uniq (g)
    `((rfn (,g)
        (when ,cnd
          ,@body
          (,g))))))

(macro (point name . body)
  `(call/cc (fn (,name) ,@body)))

(def (ref x k)
  (if (vector? x) (vector-ref x k)
      (string? x) (string-ref x k)))

(def (list? x)
  (or (pair? x)
      (null? x)))

(def (length x)
  (if (vector? x) (vector-size x)
      (string? x) (string-length x)
      (list? x)   (list-length x)))

(def (push-back x value)
  (if (vector? x) (vector-push-back x value)
      (string? x) (string-push-back x value)))

(def (list-for-each x f)
  (unless (null? x)
    (f (car x))
    (list-for-each (cdr x) f)))

(def (string-for-each x f)
  ((afn (i)
     (when (< i (string-length x))
       (f (string-ref x i))
       (self (+ i 1))))
   0))

(def (vector-for-each x f)
  ((afn (i)
     (when (< i (vector-size x))
       (f (vector-ref x i))
       (self (+ i 1))))
   0))

(def (is-a x y) (is (type x) y))

(def (range a b) (annotate 'range (cons a b)))
(def (range? x) (is-a x 'range))
(def (range-from r) (car (rep r)))
(def (range-to r)   (cdr (rep r)))

(def (range-for-each x f)
  ((afn (i)
     (when (< i (range-to x))
       (f i)
       (self (+ i 1))))
   (range-from x)))

(def (scons a b) (annotate 'scons (cons a b)))

(macro (seq hd tl)
  `(scons ,hd (fn () ,tl)))

(def (seq? x) (or (is-a x 'cons) (null? x)))
(def (seq-hd s) (car (rep s)))
(def (seq-tl s)
  (let (r (rep s))
    (when (fn? (cdr r))
      (set-cdr r ((cdr r))))
    (cdr r)))

(def (seq-foreach s f)
  (unless (null? s)
    (f (seq-hd s))
    (seq-for-each (seq-tl s) f)))

(def (for-each x f)
  (if (vector? x) (vector-for-each x f)
      (string? x) (string-for-each x f)
      (list? x)   (list-for-each x f)
      (range? x)  (range-for-each x f)
      (seq? x)    (seq-for-each x f)))

(macro (for x xs . body)
  `(for-each ,xs (fn (,x) ,@body)))

(def (append x . xs)
  (if (string? x) (apply string-append (cons x xs))
      (list? x)   (apply list-append (cons x xs))
      (vector? x) (apply vector-append (cons x xs))))

(def (split-string s c)
  (let (r (make-adjustable-vector))
    ((afn (i j)
            (if (= j (length s)) (vector-push-back r (substring s i j))
                (is (ref s j) c) (do
                                   (vector-push-back r (substring s i j))
                                   (self (+ j 1) (+ j 1)))
                                 (self i (+ j 1))))
     0 0)))

(def (whitespace c)
  (or (is c #\space)
      (is c #\tab)
      (is c #\newline)
      (is c #\return)))

(def (read-line)
  (when (peek-char)
    (let (r (make-adjustable-string))
      (while (aand (peek-char) (not (is it #\newline)))
        (push-back r (read-char)))
      r)))
