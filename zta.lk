(set list (fn xs xs))

(set macro
  (annotate 'macro
            (fn (sig &rest body)
              `(set ,(car sig)
                    (annotate 'macro (fn ,(cdr sig) ,@body))))))

(macro (def sig &rest body)
  (if (symbol? sig)
      `(set ,sig ,@body)
      `(set ,(car sig) (fn ,(cdr sig) ,@body))))

(def (is-a x y) (is (type x) y))

(def (macro? x) (is-a x 'macro))

(def (cadr x) (car (cdr x)))
(def (cddr x) (cdr (cdr x)))
(def (caar x) (car (car x)))
(def (cdar x) (cdr (car x)))

(def (isnt x y) (not (is x y)))

(def (null? x) (is x nil))
(def (not x) (is x nil))
(def (no x) (is x nil))

(macro (rfn sig &rest body)
  ((fn (name params)
     `((fn (,name)
         (set ,name (fn ,params ,@body))
         ,name)
       nil))
   (car sig) (cdr sig)))

(macro (afn params &rest body)
  `(rfn (self ,@params) ,@body))

(def (list-length xs)
  ((afn (n xs)
     (if (null? xs)
         n
         (self (+ n 1) (cdr xs))))
   0 xs))

(def (reverse xs)
  ((afn (rs xs)
     (if (null? xs)
         rs
         (self (cons (car xs) rs) (cdr xs))))
   nil xs))

(def (pair xs)
  ((afn (ps xs)
     (if (null? xs)       (reverse ps)
         (null? (cdr xs)) (self (cons (list (car xs)) ps) nil)
                          (self (cons (cons (car xs) (cadr xs)) ps) (cddr xs))))
   nil xs))

(def (intersperse xs ys)
  (if (null? xs)
      ys
      (cons (car xs) (intersperse ys (cdr xs)))))

(def (list-map f xs)
  ((afn (rs xs)
     (if (null? xs)
         (reverse rs)
         (self (cons (f (car xs)) rs) (cdr xs))))
   nil xs))

(def (car-is p x) (is (car p) x))

(macro (with bindings &rest body)
  ((fn (gen)
     ((rfn (destructure pb vars exprs rest)
         (if (null? pb)          (gen vars exprs rest)
             (symbol? (caar pb)) (destructure (cdr pb)
                                              (cons (caar pb) vars)
                                              (cons (cdar pb) exprs)
                                              rest)
             (car-is (caar pb) 'vector)
               ((afn (g)
                  (destructure (cdr pb)
                               (cons g vars)
                               (cons (cdar pb) exprs)
                               (list-append ((afn (xs rs n)
                                               (if (null? xs)
                                                   rs
                                                   (self (cdr xs)
                                                         (cons (car xs) (cons `(ref ,g ,n) rs))
                                                         (+ n 1))))
                                             (cdr (caar pb)) nil 0)
                                            rest)))
                (gensym))
             true                (error "Can't parse binding: " (caar pb))))
         (pair bindings) nil nil nil))
   (fn (vars exprs rest)
     (if (null? rest)
       `((fn ,vars ,@body) ,@exprs)
       `((fn ,vars (with ,rest ,@body)) ,@exprs)))))

(macro (let var expr &rest body)
  `(with (,var ,expr)
     ,@body))

(macro (withs bindings &rest body)
  (if (null? bindings)
      `(do ,@body)
      `(with (,(car bindings) ,(cadr bindings))
         (withs ,(cddr bindings)
           ,@body))))

(macro (w/uniq names &rest body)
  `(with ,(intersperse names (list-map (fn (_) '(gensym)) names))
     ,@body))

(def (list-ref xs i)
  (if (= i 0)
      (car xs)
      (list-ref (cdr xs) (- i 1))))

(macro (after x &rest body)
  (w/uniq (g)
    `(let ,g ,x
       ,@body ,g)))

(macro (push x l)
  `(set ,l (cons ,x ,l)))

(macro (pop l)
  (w/uniq (g)
    `(let ,g (car ,l)
       (set ,l (cdr ,l))
       ,g)))

(macro (and &rest args)
  (if (null? args)       'true
      (null? (cdr args)) (car args)
                         `(if ,(car args) (and ,@(cdr args)))))

(macro (or &rest args)
  (if (null? args)
      'false
      (w/uniq (g)
        `(let ,g ,(car args)
           (if ,g ,g (or ,@(cdr args)))))))

(macro (aand x &rest args)
  `(let it ,x
     (and it ,@args)))

(macro (do &rest body)
  `((fn () ,@body)))

(macro (when cnd &rest body)
  `(if ,cnd (do ,@body)))

(macro (unless cnd &rest body)
  `(if (not ,cnd) (do ,@body)))

(macro (while cnd &rest body)
  (w/uniq (g)
    `((rfn (,g)
        (when ,cnd
          ,@body
          (,g))))))

(macro (whiler var expr cnd &rest body)
  (w/uniq (iter)
    `((rfn (,iter)
        (let ,var ,expr
          (if ,cnd
            (do ,@body
                (,iter))
            ,var))))))

(macro (point name &rest body)
  `(call/cc (fn (,name) ,@body)))

(def (list? x)
  (or (pair? x)
      (null? x)))

(macro (defg sig)
  (withs (name (car sig)
          params (cdr sig)
          vtable (symbol (append (symbol-name name) "-vtable"))
          f (gensym))
    `(do
       (def ,vtable (make-dict))
       (def (,name ,@params)
         (let ,f (dict-ref ,vtable (type ,(car params)))
           (,f ,@params))))))

(macro (defm sig &rest body)
  (withs (name (car sig)
          params (cdr sig)
          vtable (symbol (append (symbol-name name) "-vtable")))
    `(dict-set ,vtable
               (quote ,(cadr (car params)))
               (fn ,(cons (car (car params)) (cdr params)) ,@body))))

(def (vector-empty? x) (= (vector-size x) 0))
(def (string-empty? x) (= (string-length x) 0))
(def (dict-empty? x) (= (dict-size x) 0))

(def (empty? x)
  (if (pair? x) false
      (null? x) true
      (vector? x) (vector-empty? x)
      (string? x) (string-empty? x)
      (dict? x)   (dict-empty? x)
                  (error 'empty "not a container")))

(def (ref x k)
  (if (pair? x)   (list-ref x k)
      (vector? x) (vector-ref x k)
      (bytes? x)  (bytes-ref x k)
      (string? x) (string-ref x k)
      (dict? x) (dict-ref x k)))

(def (length x)
  (if (vector? x) (vector-size x)
      (bytes? x)  (bytes-size x)
      (string? x) (string-length x)
      (list? x)   (list-length x)))

(macro (in x &rest xs)
  (w/uniq (g)
    `(let ,g ,x
       (or ,@(list-map (fn (x) `(is ,g ,x)) xs)))))

(macro (case-let var expr &rest args)
  (let ex (afn (args)
            (if (null? (cdr args))
                (car args)
                `(if (is ,var ,(car args))
                     ,(cadr args)
                     ,(self (cddr args)))))
    `(let ,var ,expr
       ,(ex args))))

(macro (case expr &rest args)
  (w/uniq (g)
    `(case-let ,g ,expr ,@args)))

(def (reduce f x0 xs)
  (if (null? xs)
      x0
      (reduce f (f x0 (car xs)) (cdr xs))))

(def (best f xs)
  (unless (null? xs)
    (reduce (fn (a b) (if (f a b) a b)) (car xs) (cdr xs))))

(def (min &rest xs) (best < xs))
(def (max &rest xs) (best > xs))

(def (neg f) (fn (x) (not (f x))))

(def (capacity x)
  (if (vector? x) (vector-capacity x)
      (bytes? x)  (bytevector-capacity x)
      (string? x) (string-capacity x)))

(def (push-back x value)
  (if (vector? x) (vector-push-back x value)
      (bytes? x)  (bytevector-push-back x value)
      (string? x) (string-push-back x value)))

(macro (accumulate-to-string acc-fn &rest body)
  (w/uniq (gs)
    `(withs (,gs (make-adjustable-string)
             ,acc-fn (fn (c) (string-push-back ,gs c)))
       ,@body
       ,gs)))

(macro (accumulate-to-vector acc-fn &rest body)
  (w/uniq (gv)
    `(withs (,gv (make-adjustable-vector)
             ,acc-fn (fn (c) (vector-push-back ,gv c)))
       ,@body
       ,gv)))

(macro (accumulate-to-dict acc-fn &rest body)
  (w/uniq (gd)
    `(withs (,gd (make-dict)
             ,acc-fn (fn (k v) (dict-set ,gd k v)))
       ,@body
       ,gd)))

(macro (for x xs &rest body)
  (if (symbol? x)        `(for-each ,xs (fn (,x) ,@body))
      (pair? x)          (w/uniq (g)
                           `(for-each ,xs (fn (,g) (let ,x ,g ,@body))))
                         (error "Can't destructure " x)))

(def (append &rest xs)
  (let x (car xs)
    (if (string? x) (apply string-append xs)
        (list? x)   (apply list-append xs)
        (vector? x) (apply vector-append xs))))

(macro (accumulate-reversed acc-fn &rest body)
  (w/uniq (gl)
    `(withs (,gl nil
             ,acc-fn (fn (x) (push x ,gl)))
       ,@body
       ,gl)))

(macro (accumulate acc-fn &rest body)
  `(reverse (accumulate-reversed ,acc-fn ,@body)))

(def (less-than n) (fn (x) (< x n)))
(def (more-than n) (fn (x) (> x n)))

(def (dict &rest content)
  (accumulate-to-dict acc
    ((afn (xs)
       (if (null? xs)       nil
           (null? (cdr xs)) (acc (car xs) nil)
                            (do (acc (car xs) (cadr xs))
                                (self (cddr xs)))))
      content)))

(def (read-char &opt s skip-space)
  (if skip-space (peek-char s true))
  (cl-read-char s))

(def (read-line &opt s)
  (if (peek-char s)
    (accumulate-to-string acc
      (whiler c (read-char s) (not (in c nil #\newline))
        (acc c)))))

(def (whitespace c)
  (or (is c #\space)
      (is c #\tab)
      (is c #\newline)
      (is c #\return)))

(macro (with-input-from-string var str &rest body)
  `(let ,var (open-input-string ,str)
     ,@body))

(macro (with-output-to-string var &rest body)
  `(let ,var (open-output-string)
     ,@body
     (get-output-string ,var)))

(macro (with-input-from-file var path &rest body)
  `(let ,var (open-input-file ,path)
     (after (do ,@body) (close ,var))))

(def (atom-delimiter? c)
  (or (whitespace c)
      (in c #\) #\( #\[ #\] #\{ #\})))

(def void (annotate 'iomanip nil))
(def (void? x) (is x void))
(def flush (annotate 'iomanip nil))
(def (flush? x) (is x flush))

(def (fprint s &rest args)
  (for x args
    (if (void? x) true
        (flush? x) (flush-output s)
                   (cl-print x s))))

(def (print &rest args)
  (apply fprint (cons nil args)))

(def (println &rest args)
  (apply print args)
  (print #\newline))

(def (error msg &rest rest)
  (apply println (cons msg rest))
  (throw 'read-error))

(def (read-delimited-list d s)
  ((afn (rs)
     (case (peek-char s true)
       nil (error "Expected " d)
       d   (do (read-char s) (reverse rs))
           (self (cons (read s true) rs))))
   nil))

(def (read-string &opt s)
  (let next-char (fn () (or (read-char s) (error 'read-string "unexpected end of file")))
    (when (is (read-char s true) #\")
      (accumulate-to-string acc
        (whiler c (next-char) (isnt c #\")
          (case c
            #\\ (case-let nc (next-char)
                  #\n (acc #\newline)
                  #\t (acc #\tab)
                      (acc nc))
                (acc c)))))))

(def (read-atom-as-string &opt s)
  (if (peek-char s true)
    (accumulate-to-string acc
      (whiler c (peek-char s) (and c (not (atom-delimiter? c)))
        (acc (read-char s))))))

(def (testify x)
  (if (fn? x)
      x
      (fn (y) (is x y))))

(def (read-until test &opt s)
  (let f (testify test)
    (accumulate-to-string acc
      (whiler c (peek-char s) (and c (not (f c)))
        (acc (read-char s))))))

(w/uniq (eof)

  (def (eof? x) (is x eof))

  (def (read-atom &opt s)
    (let str (read-atom-as-string s)
      (if str
        (with-input-from-string ss str (cl-read ss))
        eof)))

  (def (read-hash-value &opt s)
    (let next-char (fn () (or (read-char s) (error 'read-string "unexpected end of file")))
      (when (is (read-char s true) #\#)
        (let str (with-output-to-string ss
                   (case-let c (next-char)
                     #\\ (let nc (next-char)
                           (fprint ss #\# c nc (if (atom-delimiter? nc)
                                                   void
                                                   (read-until atom-delimiter? s))))
                         (fprint ss #\# c (read-until atom-delimiter? s))))
          (with-input-from-string ss str (cl-read ss))))))

  (def (read &opt s error-on-eof)
    (case-let c (peek-char s true)
      nil (if error-on-eof (error "Unexpected EOF.") eof)
      #\" (read-string s)
      #\# (read-hash-value s)
      #\( (do (read-char s) (read-delimited-list #\) s))
      #\[ (do (read-char s) (cons 'vector (read-delimited-list #\] s)))
      #\{ (do (read-char s) (cons 'dict (read-delimited-list #\} s)))
      #\' (do (read-char s) (list 'quote (read s true)))
      #\` (do (read-char s) (list 'quasiquote (read s true)))
      #\, (do (read-char s)
              (if (is (peek-char s) #\@)
                  (do (read-char s)
                      (list 'unquote-splicing (read s true)))
                  (list 'unquote (read s true))))
          (read-atom s)))
)

(def (load path)
  (with-input-from-file f path
    (whiler e (read f) (not (eof? e))
      (eval e))))

(def (make-padder s)
  (let first true
    (fn () (if first (set first false) (fprint s #\space)))))

(macro (w/padder p s &rest body)
  `(let ,p (make-padder ,s)
     ,@body))

(def (write-vector x &opt s)
  (fprint s #\[)
  (w/padder pad s
    (for elem x
      (pad)
      (write elem s)))
  (fprint s #\]))

(def (write-dict x &opt s)
  (fprint s #\{)
  (w/padder pad s
    (dict-for-each x (fn (key value)
                       (pad)
                       (write key s)
                       (pad)
                       (write value s))))
  (fprint s #\}))

(def (write x &opt s)
  (if (vector? x) (write-vector x s)
      (symbol? x) (write-symbol x s)
      (dict? x)   (write-dict x s)
                  (cl-write x)))

(def (writeln x &opt s)
  (write x s)
  (write-char #\newline s))

(load "math.lk")
(load "strings.lk")
(load "seq.lk")
(load "records.lk")
(load "algorithms.lk")
(load "sys.lk")
(load "sockets.lk")

(def repl-prompt "ztalk> ")

(def (print-repl-prompt)
  (print repl-prompt flush))

(def (repl)
  (let prompt-and-read (fn ()
                         (print-repl-prompt)
                         (read))
    (whiler e (prompt-and-read) (not (eof? e))
      (writeln (eval e)))))

(repl)
