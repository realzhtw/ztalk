(set list (fn xs xs))

(set macro
  (annotate 'macro
            (fn (sig . body)
              `(set ,(car sig)
                    (annotate 'macro (fn ,(cdr sig) ,@body))))))

(macro (def sig . body)
  (if (symbol? sig)
      `(set ,sig ,@body)
      `(set ,(car sig) (fn ,(cdr sig) ,@body))))

(def (is-a x y) (is (type x) y))

(def (macro? x) (is-a x 'macro))

(def (cadr x) (car (cdr x)))
(def (cddr x) (cdr (cdr x)))

(macro (push x l)
  `(set ,l (cons ,x ,l)))

(macro (pop l)
  (w/uniq (g)
    `(let (g (car ,l))
       (set ,l (cdr ,l)))))

(def (isnt x y) (not (is x y)))

(def (null? x) (is x nil))
(def (not x) (is x nil))
(def (no x) (is x nil))

(macro (rfn sig . body)
  ((fn (name params)
     `((fn (,name)
         (set ,name (fn ,params ,@body))
         ,name)
       nil))
   (car sig) (cdr sig)))

(macro (afn params . body)
  `(rfn (self ,@params) ,@body))

(def (list-length xs)
  ((afn (n xs)
     (if (null? xs)
         n
         (self (+ n 1) (cdr xs))))
   0 xs))

(def (reverse xs)
  ((afn (rs xs)
     (if (null? xs)
         rs
         (self (cons (car xs) rs) (cdr xs))))
   nil xs))

(def (pair xs)
  ((afn (ps xs)
     (if (null? xs)       (reverse ps)
         (null? (cdr xs)) (self (cons (list (car xs)) ps) nil)
                          (self (cons (list (car xs) (cadr xs)) ps) (cddr xs))))
   nil xs))

(def (intersperse xs ys)
  (if (null? xs)
      ys
      (cons (car xs) (intersperse ys (cdr xs)))))

(def (map f xs)
  ((afn (rs xs)
     (if (null? xs)
         (reverse rs)
         (self (cons (f (car xs)) rs) (cdr xs))))
   nil xs))

(macro (let bindings . body)
  ((fn (paired-bindings)
     `((fn ,(map car paired-bindings) ,@body) ,@(map cadr paired-bindings)))
   (pair bindings)))

(macro (let* bindings . body)
  (if (null? bindings)
      `(do ,@body)
      `(let (,(car bindings) ,(cadr bindings))
         (let* ,(cddr bindings)
           ,@body))))

(macro (w/uniq names . body)
  `(let ,(intersperse names (map (fn (_) '(gensym)) names))
     ,@body))

(macro (and . args)
  (if (null? args)       'true
      (null? (cdr args)) (car args)
                         `(if ,(car args) (and ,@(cdr args)))))

(macro (or . args)
  (if (null? args)
      'false
      (w/uniq (g)
        `(let (,g ,(car args))
           (if ,g ,g (or ,@(cdr args)))))))

(macro (aand x . args)
  `(let (it ,x)
     (and it ,@args)))

(macro (after x . body)
  (w/uniq (g)
    `(let (,g ,x) ,@body ,g)))

(macro (do . body)
  `((fn () ,@body)))

(macro (when cnd . body)
  `(if ,cnd (do ,@body)))

(macro (unless cnd . body)
  `(if (not ,cnd) (do ,@body)))

(macro (while cnd . body)
  (w/uniq (g)
    `((rfn (,g)
        (when ,cnd
          ,@body
          (,g))))))

(macro (whiler var expr cnd . body)
  (w/uniq (iter)
    `((rfn (,iter)
        (let (,var ,expr)
          (if ,cnd
            (do ,@body
                (,iter))
            ,var))))))

(macro (point name . body)
  `(call/cc (fn (,name) ,@body)))

(def (list? x)
  (or (pair? x)
      (null? x)))

(macro (defg sig)
  (let* (name (car sig)
         params (cdr sig)
         vtable (symbol (append (symbol-name name) "-vtable"))
         f (gensym))
    `(do
       (def ,vtable (make-dict))
       (def (,name ,@params)
         (let (,f (dict-ref ,vtable (type ,(car params))))
           (,f ,@params))))))

(macro (defm sig . body)
  (let* (name (car sig)
         params (cdr sig)
         vtable (symbol (append (symbol-name name) "-vtable")))
    `(dict-set ,vtable
               (quote ,(cadr (car params)))
               (fn ,(cons (car (car params)) (cdr params)) ,@body))))

(def (ref x k)
  (if (vector? x) (vector-ref x k)
      (string? x) (string-ref x k)
      (dict? x) (dict-ref x k)))

(def (length x)
  (if (vector? x) (vector-size x)
      (string? x) (string-length x)
      (list? x)   (list-length x)))

(def (reduce f x0 xs)
  (if (null? xs)
      x0
      (reduce f (f x0 (car xs)) (cdr xs))))

(def (best f xs)
  (unless (null? xs)
    (reduce (fn (a b) (if (f a b) a b)) (car xs) (cdr xs))))

(def (min . xs) (best < xs))
(def (max . xs) (best > xs))

(def (neg f) (fn (x) (not (f x))))

(def (push-back x value)
  (if (vector? x) (vector-push-back x value)
      (string? x) (string-push-back x value)))

(def (list-for-each x f)
  (unless (null? x)
    (f (car x))
    (list-for-each (cdr x) f)))

(def (string-for-each x f)
  ((afn (i)
     (when (< i (string-length x))
       (f (string-ref x i))
       (self (+ i 1))))
   0))

(def (vector-for-each x f)
  ((afn (i)
     (when (< i (vector-size x))
       (f (vector-ref x i))
       (self (+ i 1))))
   0))

(def (range a b) (annotate 'range (cons a b)))
(def (range? x) (is-a x 'range))
(def (range-from r) (car (rep r)))
(def (range-to r)   (cdr (rep r)))

(def (range-for-each x f)
  ((afn (i)
     (when (< i (range-to x))
       (f i)
       (self (+ i 1))))
   (range-from x)))

(def (scons a b) (annotate 'scons (cons a b)))

(macro (seq hd tl)
  `(scons ,hd (fn () ,tl)))

(def (seq? x) (or (null? x) (is-a x 'scons)))
(def (seq-hd s) (car (rep s)))
(def (seq-tl s)
  (let (r (rep s))
    (when (fn? (cdr r))
      (set-cdr r ((cdr r))))
    (cdr r)))

(def (seq->list s)
  ((afn (r s)
     (if (null? s)
         (reverse r)
         (self (cons (hd s) r) (tl s))))
   nil s))

(def (seq-for-each s f)
  (unless (null? s)
    (f (seq-hd s))
    (seq-for-each (seq-tl s) f)))

(def (for-each x f)
  (if (vector? x) (vector-for-each x f)
      (string? x) (string-for-each x f)
      (list? x)   (list-for-each x f)
      (range? x)  (range-for-each x f)
      (seq? x)    (seq-for-each x f)))

(def (hd s)
  (if (pair? s)
      (car s)
      (seq-hd s)))

(def (tl s)
  (if (pair? s)
      (cdr s)
      (seq-tl s)))

(macro (for x xs . body)
  `(for-each ,xs (fn (,x) ,@body)))

(def (enumerate s n)
  (if (null? s)
      nil
      (seq (list n (hd s)) (enumerate (tl s) (+ n 1)))))

(def (append x . xs)
  (if (string? x) (apply string-append (cons x xs))
      (list? x)   (apply list-append (cons x xs))
      (vector? x) (apply vector-append (cons x xs))))

(macro (accumulate-reversed acc-fn . body)
  (w/uniq (gl)
    `(let* (,gl nil
            ,acc-fn (fn (x) (push x ,gl)))
       ,@body
       ,gl)))

(macro (accumulate acc-fn . body)
  `(reverse (accumulate-reversed ,acc-fn ,@body)))

(def (record? x) (is-a x 'record))

(macro (record name . fields)
  (let* (nm (symbol-name name)
         nf (length fields))
    `(do
       (def (,(symbol (append "make-" nm)) ,@fields)
         (annotate 'record
                   (vector (quote ,name) ,@fields)))
       (def (,(symbol (append nm "?")) x)
         (and (record? x)
              (is (vector-ref (rep x) 0) (quote ,name))))
       ,@(accumulate acc
           (w/uniq (g)
             (for x (enumerate fields 1)
               (let (i (car x)
                     f (cadr x))
                 (acc `(def (,(symbol (append nm "-" (symbol-name f))) ,g)
                         (vector-ref (rep ,g) ,i))))))))))

(macro (accumulate-to-string acc-fn . body)
  (w/uniq (gs)
    `(let* (,gs (make-adjustable-string)
            ,acc-fn (fn (c) (string-push-back ,gs c)))
       ,@body
       ,gs)))

(macro (accumulate-to-vector acc-fn . body)
  (w/uniq (gv)
    `(let* (,gv (make-adjustable-vector)
            ,acc-fn (fn (c) (vector-push-back ,gv c)))
       ,@body
       ,gv)))

(def (split-string s c)
  (accumulate-to-vector acc
    ((afn (i j)
       (if (= j (length s)) (acc (substring s i j))
           (is (ref s j) c) (do
                              (acc (substring s i j))
                              (self (+ j 1) (+ j 1)))
                            (self i (+ j 1))))
     0 0)))

(macro (in x . xs)
  (w/uniq (g)
    `(let (,g ,x)
       (or ,@(map (fn (x) `(is ,g ,x)) xs)))))

(def (whitespace c)
  (or (is c #\space)
      (is c #\tab)
      (is c #\newline)
      (is c #\return)))

(macro (case-let var expr . args)
  (let (ex (afn (args)
             (if (null? (cdr args))
                 (car args)
                 `(if (is ,var (quote ,(car args)))
                      ,(cadr args)
                      ,(self (cddr args))))))
    `(let (,var ,expr) ,(ex args))))

(macro (case expr . args)
  (w/uniq (g)
    `(case-let ,g ,expr ,@args)))

(def (skip-space &opt s)
  (whiler c (peek-char s) (whitespace c)
    (read-char s)))

(def (read &opt s)
  (skip-space s)
  (case (peek-char s)
    #\[ (do (read-char) (cons 'vector (read-delimited-list #\] s)))
    #\( (do (read-char) (read-delimited-list #\) s))
        (cl-read s)))

(def (read-line &opt s)
  (if (peek-char s)
    (accumulate-to-string acc
      (whiler c (read-char s) (not (in c nil #\newline))
        (acc c)))))
