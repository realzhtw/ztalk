(set list (fn xs xs))

(set macro
  (annotate 'macro
            (fn (sig &rest body)
              `(set ,(car sig)
                    (annotate 'macro (fn ,(cdr sig) ,@body))))))

(macro (def sig &rest body)
  (if (symbol? sig)
      `(set ,sig ,@body)
      `(set ,(car sig) (fn ,(cdr sig) ,@body))))

(macro (do &rest body)
  `((fn () ,@body)))

(def (is-a x y) (is (type x) y))

(def (macro? x) (is-a x 'macro))

(def (callable? x)
  (proc? (rep x)))

(def (cadr x) (car (cdr x)))
(def (cddr x) (cdr (cdr x)))
(def (caar x) (car (car x)))
(def (cdar x) (cdr (car x)))

(def (isnt x y) (not (is x y)))

(def (null? x) (is x nil))
(def (not x) (is x nil))
(def (no x) (is x nil))

(macro (reset x)
  `(set ,x nil))

(macro (rfn sig &rest body)
  ((fn (name params)
     `((fn (,name)
         (set ,name (fn ,params ,@body))
         ,name)
       nil))
   (car sig) (cdr sig)))

(macro (afn params &rest body)
  `(rfn (self ,@params) ,@body))

(def (list-length xs)
  ((afn (n xs)
     (if (null? xs)
         n
         (self (+ n 1) (cdr xs))))
   0 xs))

(def (reverse xs)
  ((afn (rs xs)
     (if (null? xs)
         rs
         (self (cons (car xs) rs) (cdr xs))))
   nil xs))

(def (remove x l)
  ((afn (r l)
     (if (null? l)      (reverse r)
         (is x (car l)) (self r (cdr l))
                        (self (cons (car l) r) (cdr l))))
   nil l))

(def (pair xs)
  ((afn (ps xs)
     (if (null? xs)       (reverse ps)
         (null? (cdr xs)) (self (cons (list (car xs)) ps) nil)
                          (self (cons (cons (car xs) (cadr xs)) ps) (cddr xs))))
   nil xs))

(def (intersperse xs ys)
  (if (null? xs)
      ys
      (cons (car xs) (intersperse ys (cdr xs)))))

(def (list-map f xs)
  ((afn (rs xs)
     (if (null? xs)
         (reverse rs)
         (self (cons (f (car xs)) rs) (cdr xs))))
   nil xs))

(macro (and &rest args)
  (if (null? args)       'true
      (null? (cdr args)) (car args)
                         `(if ,(car args) (and ,@(cdr args)))))

(def (car-is x y)
  (and (pair? x)
       (is (car x) y)))

(macro (with bindings &rest body)
  ((fn (gen)
     ((rfn (destructure pb vars exprs rest)
         (if (null? pb)          (gen vars exprs rest)
             (symbol? (caar pb)) (destructure (cdr pb)
                                              (cons (caar pb) vars)
                                              (cons (cdar pb) exprs)
                                              rest)
             (car-is (caar pb) 'vector)
               ((afn (g)
                  (destructure (cdr pb)
                               (cons g vars)
                               (cons (cdar pb) exprs)
                               (list-append ((afn (xs rs n)
                                               (if (null? xs)
                                                   rs
                                                   (self (cdr xs)
                                                         (cons (car xs) (cons `(ref ,g ,n) rs))
                                                         (+ n 1))))
                                             (cdr (caar pb)) nil 0)
                                            rest)))
                (gensym))
             true                (error "Can't parse binding: " (caar pb))))
         (pair bindings) nil nil nil))
   (fn (vars exprs rest)
     (if (null? rest)
       `((fn ,vars ,@body) ,@exprs)
       `((fn ,vars (with ,rest ,@body)) ,@exprs)))))

(macro (let var expr &rest body)
  `(with (,var ,expr)
     ,@body))

(macro (withs bindings &rest body)
  (if (null? bindings)
      `(do ,@body)
      `(with (,(car bindings) ,(cadr bindings))
         (withs ,(cddr bindings)
           ,@body))))

(macro (w/uniq names &rest body)
  `(with ,(intersperse names (list-map (fn (_) '(gensym)) names))
     ,@body))

(macro (or &rest args)
  (if (null? args)
      'false
      (w/uniq (g)
        `(let ,g ,(car args)
           (if ,g ,g (or ,@(cdr args)))))))

(def make-param
  (let sentinel (gensym)
    (fn (x)
      (let value x
        (fn (&opt (new-value sentinel))
          (if (is new-value sentinel)
            value
            (set value new-value)))))))

(macro (defp name value)
  `(def ,name (make-param ,value)))

(macro (point name &rest body)
  (w/uniq (k)
    `(call/cc
       (fn (,k)
         (let ,name (fn (&opt x) (,k x))
           ,@body)))))

(def (ignore &rest args) nil)

(defp current-exception-handler ignore)

(def (call-with-exception-handler h thunk)
  (let old-handler (current-exception-handler)
    (point done
      (current-exception-handler (fn (e)
                                   (current-exception-handler old-handler)
                                   (done (h e))))
      (let value (thunk)
        (current-exception-handler old-handler)
        value))))

(macro (guard handler &rest body)
  `(call-with-exception-handler ,handler (fn () ,@body)))

(def (raise e)
  ((current-exception-handler) e))

(def (protect thunk after-thunk)
  (guard (fn (e) (after-thunk) (raise e))
    (let value (thunk)
      (after-thunk)
      value)))

(macro (after x &rest rest)
  `(protect (fn () ,x)
     (fn () ,@rest)))

(def (call-with-param param value thunk)
  (let old-value (param)
    (param value)
    (protect thunk
      (fn () (param old-value)))))

(macro (w/param param value &rest body)
  `(call-with-param ,param ,value (fn () ,@body)))

(def (list-ref xs i)
  (if (= i 0)
      (car xs)
      (list-ref (cdr xs) (- i 1))))

(macro (push x l)
  `(set ,l (cons ,x ,l)))

(macro (pop l)
  (w/uniq (g)
    `(let ,g (car ,l)
       (set ,l (cdr ,l))
       ,g)))

(macro (aand x &rest args)
  `(let it ,x
     (and it ,@args)))

(macro (when cnd &rest body)
  `(if ,cnd (do ,@body)))

(macro (unless cnd &rest body)
  `(if (not ,cnd) (do ,@body)))

(macro (while cnd &rest body)
  (w/uniq (g)
    `((rfn (,g)
        (when ,cnd
          ,@body
          (,g))))))

(macro (repeat n &rest body)
  (w/uniq (f i gn)
    `((rfn (,f ,i)
        (when (> ,i 0)
          ,@body
          (,f (- ,i 1))))
      ,n)))

(macro (for-len var x &rest body)
  (w/uniq (iter n)
    `(let ,n (length ,x)
       ((rfn (,iter ,var)
          (when (< ,var ,n)
            ,@body
            (,iter (+ ,var 1))))
        0))))

(def (bound-symbol? x)
  (and (symbol? x)
       (bound? x)))

(def (macroexpand x)
  (if (and (pair? x)
           (bound-symbol? (car x))
           (is-a (symbol-value (car x)) 'macro))
      (apply (rep (symbol-value (car x))) (cdr x))
      x))


(macro (whiler var expr cnd &rest body)
  (w/uniq (iter)
    `((rfn (,iter)
        (let ,var ,expr
          (if ,cnd
            (do ,@body
                (,iter))
            ,var))))))

(def (list? x)
  (or (pair? x)
      (null? x)))

(macro (def-generic sig &rest body)
  (withs (name (car sig)
          params (cdr sig)
          vtable (symbol (append (symbol-name name) "-vtable"))
          f (gensym))
    `(do
       (def ,vtable (make-dict))
       (def (,name ,@params)
         (let ,f (dict-ref ,vtable (type ,(car params)))
           (if ,f
             (,f ,@(remove '&opt params))
             ,(if (no body)
                '(raise 'generic-not-defined)
                `(do ,@body))))))))

(macro (def-method sig &rest body)
  (withs (name (car sig)
          params (cdr sig)
          vtable (symbol (append (symbol-name name) "-vtable")))
    `(dict-set ,vtable
               (quote ,(cadr (car params)))
               (fn ,(cons (caar params) (cdr params)) ,@body))))

(def (vector-empty? x) (= (vector-size x) 0))
(def (string-empty? x) (= (string-length x) 0))
(def (dict-empty? x) (= (dict-size x) 0))

(def (empty? x)
  (if (pair? x) false
      (null? x) true
      (vector? x) (vector-empty? x)
      (string? x) (string-empty? x)
      (dict? x)   (dict-empty? x)
                  (error 'empty "not a container")))

(def (ref x k)
  (if (vector? x) (vector-ref x k)
      (bytes? x)  (bytes-ref x k)
      (string? x) (string-ref x k)
      (dict? x)   (dict-ref x k)
      (pair? x)   (list-ref x k)))

(def (length x)
  (if (vector? x) (vector-size x)
      (bytes? x)  (bytes-size x)
      (string? x) (string-length x)
      (list? x)   (list-length x)))

(macro (if-let var expr &rest rest)
  `(let ,var ,expr
     (if ,var ,@rest)))

(macro (in x &rest xs)
  (w/uniq (g)
    `(let ,g ,x
       (or ,@(list-map (fn (x) `(is ,g ,x)) xs)))))

(macro (case-let var expr &rest args)
  (let ex (afn (args)
            (if (null? (cdr args))
                (car args)
                `(if (is ,var ,(car args))
                     ,(cadr args)
                     ,(self (cddr args)))))
    `(let ,var ,expr
       ,(ex args))))

(macro (case expr &rest args)
  (w/uniq (g)
    `(case-let ,g ,expr ,@args)))

(def (reduce f x0 xs)
  (if (null? xs)
      x0
      (reduce f (f x0 (car xs)) (cdr xs))))

(def (best f xs)
  (unless (null? xs)
    (reduce (fn (a b) (if (f a b) a b)) (car xs) (cdr xs))))

(def (min &rest xs) (best < xs))
(def (max &rest xs) (best > xs))

(def (neg f) (fn (x) (not (f x))))

(def (capacity x)
  (if (vector? x) (vector-capacity x)
      (bytes? x)  (bytevector-capacity x)
      (string? x) (string-capacity x)))

(def (push-back x value)
  (if (vector? x) (vector-push-back x value)
      (bytes? x)  (bytevector-push-back x value)
      (string? x) (string-push-back x value)))

(macro (accumulate-to-string acc-fn &rest body)
  (w/uniq (gs)
    `(withs (,gs (make-adjustable-string)
             ,acc-fn (fn (c) (string-push-back ,gs c)))
       ,@body
       ,gs)))

(macro (accumulate-to-vector acc-fn &rest body)
  (w/uniq (gv)
    `(withs (,gv (make-adjustable-vector)
             ,acc-fn (fn (c) (vector-push-back ,gv c)))
       ,@body
       ,gv)))

(macro (accumulate-to-dict acc-fn &rest body)
  (w/uniq (gd)
    `(withs (,gd (make-dict)
             ,acc-fn (fn (k v) (dict-set ,gd k v)))
       ,@body
       ,gd)))

(def (vector-for-each x f)
  ((afn (i)
     (when (< i (vector-size x))
       (f (vector-ref x i))
       (self (+ i 1))))
   0))

(def (for-each x f)
  (if (vector? x) (vector-for-each x f)
      (string? x) (string-for-each x f)
      (list? x)   (list-for-each x f)
      (dict? x)   (dict-for-each x f)
      (range? x)  (range-for-each x f)
      (seq? x)    (seq-for-each x f)
                  (raise 'generic-type-error)))

(macro (for var xs &rest body)
  (if (symbol? var)        `(for-each ,xs (fn (,var) ,@body))
      (car-is var 'vector) (w/uniq (g)
                           `(for-each ,xs (fn (,g) (let ,var ,g ,@body))))
      (pair? var)          `(for-each ,xs (fn ,var ,@body))
                           (error "Can't destructure " x)))

(def (append &rest xs)
  (let x (car xs)
    (if (string? x) (apply string-append xs)
        (list? x)   (apply list-append xs)
        (vector? x) (apply vector-append xs))))

(macro (accumulate-reversed acc-fn &rest body)
  (w/uniq (gl)
    `(withs (,gl nil
             ,acc-fn (fn (x) (push x ,gl)))
       ,@body
       ,gl)))

(macro (accumulate acc-fn &rest body)
  `(reverse (accumulate-reversed ,acc-fn ,@body)))

(def (less-than n) (fn (x) (< x n)))
(def (more-than n) (fn (x) (> x n)))

(def (dict &rest content)
  (accumulate-to-dict acc
    ((afn (xs)
       (if (null? xs)       nil
           (null? (cdr xs)) (acc (car xs) nil)
                            (do (acc (car xs) (cadr xs))
                                (self (cddr xs)))))
      content)))

(defp current-source-file nil)

(defp stdin process-stdin)
(defp stdout process-stdout)
(defp stderr process-stderr)

(macro (w/stdin s &rest body)
  `(w/param stdin ,s ,@body))

(macro (w/stdout s &rest body)
  `(w/param stdout ,s ,@body))

(macro (w/stderr s &rest body)
  `(w/param stdout ,s ,@body))

(def (default-exception-handler e)
  (w/stdout (stderr)
    (println "Caught unhandled exception: " e)
    (exit 1)))

(current-exception-handler default-exception-handler)

(def (read-char &opt s skip-space)
  (if skip-space (peek-char s true))
  (cl-read-char s))

(def (read-line &opt s)
  (if (peek-char s)
    (accumulate-to-string acc
      (whiler c (read-char s) (not (in c nil #\newline))
        (acc c)))))

(def (whitespace c)
  (or (is c #\space)
      (is c #\tab)
      (is c #\newline)
      (is c #\return)))

(macro (with-input-from-string var str &rest body)
  `(let ,var (open-input-string ,str)
     ,@body))

(macro (with-output-to-string var &rest body)
  `(let ,var (open-output-string)
     ,@body
     (get-output-string ,var)))

(macro (with-input-from-file var path &rest body)
  `(let ,var (open-input-file ,path)
     (after (do ,@body) (close ,var))))

(def (atom-delimiter? c)
  (or (whitespace c)
      (in c #\) #\( #\[ #\] #\{ #\} #\_)))

(def (make-iomanip f)
  (annotate 'iomanip f))

(macro (def-iomanip sig &rest body)
  `(set ,(car sig) (make-iomanip (fn ,(cdr sig) ,@body))))

(def (iomanip? x) (is-a x 'iomanip))

(def-iomanip (void s))
(def-iomanip (flush s) (flush-output s))

(def (print &rest args)
  (let s (stdout)
    (for x args
      (write x s))))

(def (println &rest args)
  (apply print args)
  (print #\newline))

(def (error msg &rest rest)
  (apply println (cons msg rest))
  (raise 'read-error))

(def (read-delimited-list d s)
  ((afn (rs)
     (case (peek-char s true)
       nil (error "Expected " d)
       d   (do (read-char s) (reverse rs))
           (self (cons (read s true) rs))))
   nil))

(def (read-string &opt s)
  (let next-char (fn () (or (read-char s) (error 'read-string "unexpected end of file")))
    (when (is (read-char s true) #\")
      (accumulate-to-string acc
        (whiler c (next-char) (isnt c #\")
          (case c
            #\\ (case-let nc (next-char)
                  #\n (acc #\newline)
                  #\t (acc #\tab)
                      (acc nc))
                (acc c)))))))

(def (read-atom-as-string &opt s)
  (if (peek-char s true)
    (accumulate-to-string acc
      (whiler c (peek-char s) (and c (not (atom-delimiter? c)))
        (acc (read-char s))))))

(def (testify x)
  (if (proc? x)
      x
      (fn (y) (is x y))))

(def (read-until test &opt s)
  (let f (testify test)
    (accumulate-to-string acc
      (whiler c (peek-char s) (and c (not (f c)))
        (acc (read-char s))))))

(w/uniq (eof)

  (def (eof? x) (is x eof))

  (def (read-atom &opt s)
    (let str (read-atom-as-string s)
      (if str
        (let x (with-input-from-string ss str (cl-read ss))
          (let c (peek-char s)
            (if (in c #\_)
              (do (read-char s)
                  (let y (read s true)
                    `(ref ,x ,y)))
              x)))
        eof)))

  (def (read-hash-value &opt s)
    (let next-char (fn () (or (read-char s) (error 'read-string "unexpected end of file")))
      (when (is (read-char s true) #\#)
        (let str (with-output-to-string ss
                   (w/stdout ss
                     (case-let c (next-char)
                       #\\ (let nc (next-char)
                             (print #\# c nc (if (atom-delimiter? nc)
                                                     void
                                                     (read-until atom-delimiter? s))))
                           (print #\# c (read-until atom-delimiter? s)))))
          (with-input-from-string ss str (cl-read ss))))))

  (def (read &opt s error-on-eof)
    (case-let c (peek-char s true)
      nil (if error-on-eof (error "Unexpected EOF.") eof)
      #\" (read-string s)
      #\# (read-hash-value s)
      #\( (do (read-char s) (read-delimited-list #\) s))
      #\[ (do (read-char s) (cons 'vector (read-delimited-list #\] s)))
      #\{ (do (read-char s) (cons 'dict (read-delimited-list #\} s)))
      #\' (do (read-char s) (list 'quote (read s true)))
      #\` (do (read-char s) (list 'quasiquote (read s true)))
      #\, (do (read-char s)
              (if (is (peek-char s) #\@)
                  (do (read-char s)
                      (list 'unquote-splicing (read s true)))
                  (list 'unquote (read s true))))
          (read-atom s)))
)

(def (string-rfind-next s c start)
  (let test (testify c)
    ((afn (i)
      (when (>= i 0)
        (if (test (string-ref s i))
            i
            (self (- i 1)))))
     start)))

(def (string-rfind s c) (string-rfind-next s c (- (length s) 1)))

(def (path-dirname p)
  (if-let i (string-rfind p #\/)
    (substring p 0 i)
    p))

(def (load path)
  (w/param current-source-file path
    (with-input-from-file f path
      (whiler e (read f) (not (eof? e))
        (eval e)))))

(def import-paths (make-adjustable-vector))

(push-back import-paths (path-dirname (ref argv 0)))

(def import-module
  (let loaded (make-dict 'equal)
    (set loaded-modules loaded)
    (fn (name &opt force)
      (let filename (append name ".lk")
        (point done
          (for path import-paths
            (let filepath (string-append path #\/ filename)
              (when (file-exists filepath)
                (when (or (not (dict-ref loaded filepath)) force)
                  (load filepath)
                  (dict-set loaded filepath true))
                (done))))
            (raise 'import-error))))))

(macro (import module)
  `(import-module (symbol-name (quote ,module))))

(def (make-padding mortar)
  (make-iomanip (let first true
                  (fn (s)
                    (if first (reset first) (write mortar s))))))

(macro (w/padding name mortar &rest body)
  `(let ,name (make-padding ,mortar)
     ,@body))

(def (print-all xs &opt (sep #\space))
  (w/padding p sep
    (for x xs
      (print p x))))

(def (string-for-each x f)
  ((afn (i)
     (when (< i (string-length x))
       (f (string-ref x i))
       (self (+ i 1))))
   0))

(def (write-string x s)
  (string-for-each x (fn (c) (write-char c s))))

(def-generic (write x s) (cl-write x s))

(def-method (write (x string) s) (write-string x s))

(def-method (write (x vector) s)
  (w/stdout s
    (print #\[)
    (print-all x)
    (print #\])))

(def-method (write (x dict) s)
  (write-char #\{ s)
  (w/padding p #\space
    (dict-for-each x (fn (key value)
                       (write p s)
                       (write key s)
                       (write p s)
                       (write value s))))
  (write-char #\} s))

(def-method (write (x char) s) (write-char x s))

(def-method (write (x symbol) s) (write-string (symbol-name x) s))

(def-method (write (x iomanip) s) (x s))

(def-method (write (x pair) s)
  (w/stdout s
    (print #\()
    (print-all x)
    (print #\))))

(def-method (write (x macro) s)
  (w/stdout s
    (print "<macro " (fn-params (rep x)) #\>)))

(def-method (write (x fn) s)
  (w/stdout s
    (print "<fn " (fn-params x) #\>)))

(import math)
(import strings)
(import seq)
(import records)
(import algorithms)
(import sys)
(import sockets)

(def repl-prompt "ztalk> ")

(def (print-repl-prompt)
  (print repl-prompt flush))

(def (repl)
  (with (prompt-and-read (fn ()
                           (print-repl-prompt)
                           (read))
         on-error        (fn (e)
                           (println "Unhandled exception: " e)))
    (whiler e (prompt-and-read) (not (eof? e))
      (println (guard on-error
                 (eval e))))))

(repl)
