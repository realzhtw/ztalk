(set list (fn xs xs))

(set macro
  (annotate 'macro
            (fn (sig &rest body)
              `(set ,(car sig)
                    (annotate 'macro (fn ,(cdr sig) ,@body))))))

(macro (def sig &rest body)
  (if (symbol? sig)
      `(set ,sig ,@body)
      `(set ,(car sig) (fn ,(cdr sig) ,@body))))

(def (is-a x y) (is (type x) y))

(def (macro? x) (is-a x 'macro))

(def (cadr x) (car (cdr x)))
(def (cddr x) (cdr (cdr x)))
(def (caar x) (car (car x)))
(def (cdar x) (cdr (car x)))

(def (isnt x y) (not (is x y)))

(def (null? x) (is x nil))
(def (not x) (is x nil))
(def (no x) (is x nil))

(macro (rfn sig &rest body)
  ((fn (name params)
     `((fn (,name)
         (set ,name (fn ,params ,@body))
         ,name)
       nil))
   (car sig) (cdr sig)))

(macro (afn params &rest body)
  `(rfn (self ,@params) ,@body))

(def (list-length xs)
  ((afn (n xs)
     (if (null? xs)
         n
         (self (+ n 1) (cdr xs))))
   0 xs))

(def (reverse xs)
  ((afn (rs xs)
     (if (null? xs)
         rs
         (self (cons (car xs) rs) (cdr xs))))
   nil xs))

(def (pair xs)
  ((afn (ps xs)
     (if (null? xs)       (reverse ps)
         (null? (cdr xs)) (self (cons (list (car xs)) ps) nil)
                          (self (cons (cons (car xs) (cadr xs)) ps) (cddr xs))))
   nil xs))

(def (intersperse xs ys)
  (if (null? xs)
      ys
      (cons (car xs) (intersperse ys (cdr xs)))))

(def (list-map f xs)
  ((afn (rs xs)
     (if (null? xs)
         (reverse rs)
         (self (cons (f (car xs)) rs) (cdr xs))))
   nil xs))

(def (car-is p x) (is (car p) x))

(macro (with bindings &rest body)
  ((fn (gen)
     ((rfn (destructure pb vars exprs rest)
         (if (null? pb)          (gen vars exprs rest)
             (symbol? (caar pb)) (destructure (cdr pb)
                                              (cons (caar pb) vars)
                                              (cons (cdar pb) exprs)
                                              rest)
             (car-is (caar pb) 'vector)
               ((afn (g)
                  (destructure (cdr pb)
                               (cons g vars)
                               (cons (cdar pb) exprs)
                               (list-append ((afn (xs rs n)
                                               (if (null? xs)
                                                   rs
                                                   (self (cdr xs)
                                                         (cons (car xs) (cons `(ref ,g ,n) rs))
                                                         (+ n 1))))
                                             (cdr (caar pb)) nil 0)
                                            rest)))
                (gensym))
             true                (error "Can't parse binding: " (caar pb))))
         (pair bindings) nil nil nil))
   (fn (vars exprs rest)
     (if (null? rest)
       `((fn ,vars ,@body) ,@exprs)
       `((fn ,vars (with ,rest ,@body)) ,@exprs)))))

(macro (let var expr &rest body)
  `(with (,var ,expr)
     ,@body))

(macro (withs bindings &rest body)
  (if (null? bindings)
      `(do ,@body)
      `(with (,(car bindings) ,(cadr bindings))
         (withs ,(cddr bindings)
           ,@body))))

(macro (w/uniq names &rest body)
  `(with ,(intersperse names (list-map (fn (_) '(gensym)) names))
     ,@body))

(def (list-ref xs i)
  (if (= i 0)
      (car xs)
      (list-ref (cdr xs) (- i 1))))

(macro (after x &rest body)
  (w/uniq (g)
    `(let ,g ,x
       ,@body ,g)))

(macro (push x l)
  `(set ,l (cons ,x ,l)))

(macro (pop l)
  (w/uniq (g)
    `(let ,g (car ,l)
       (set ,l (cdr ,l))
       ,g)))

(macro (and &rest args)
  (if (null? args)       'true
      (null? (cdr args)) (car args)
                         `(if ,(car args) (and ,@(cdr args)))))

(macro (or &rest args)
  (if (null? args)
      'false
      (w/uniq (g)
        `(let ,g ,(car args)
           (if ,g ,g (or ,@(cdr args)))))))

(macro (aand x &rest args)
  `(let it ,x
     (and it ,@args)))

(macro (do &rest body)
  `((fn () ,@body)))

(macro (when cnd &rest body)
  `(if ,cnd (do ,@body)))

(macro (unless cnd &rest body)
  `(if (not ,cnd) (do ,@body)))

(macro (while cnd &rest body)
  (w/uniq (g)
    `((rfn (,g)
        (when ,cnd
          ,@body
          (,g))))))

(macro (whiler var expr cnd &rest body)
  (w/uniq (iter)
    `((rfn (,iter)
        (let ,var ,expr
          (if ,cnd
            (do ,@body
                (,iter))
            ,var))))))

(macro (point name &rest body)
  `(call/cc (fn (,name) ,@body)))

(def (list? x)
  (or (pair? x)
      (null? x)))

(macro (defg sig)
  (withs (name (car sig)
          params (cdr sig)
          vtable (symbol (append (symbol-name name) "-vtable"))
          f (gensym))
    `(do
       (def ,vtable (make-dict))
       (def (,name ,@params)
         (let ,f (dict-ref ,vtable (type ,(car params)))
           (,f ,@params))))))

(macro (defm sig &rest body)
  (withs (name (car sig)
          params (cdr sig)
          vtable (symbol (append (symbol-name name) "-vtable")))
    `(dict-set ,vtable
               (quote ,(cadr (car params)))
               (fn ,(cons (car (car params)) (cdr params)) ,@body))))

(def (ref x k)
  (if (pair? x)   (list-ref x k)
      (vector? x) (vector-ref x k)
      (bytes? x)  (bytes-ref x k)
      (string? x) (string-ref x k)
      (dict? x) (dict-ref x k)))

(def (length x)
  (if (vector? x) (vector-size x)
      (bytes? x)  (bytes-size x)
      (string? x) (string-length x)
      (list? x)   (list-length x)))

(macro (in x &rest xs)
  (w/uniq (g)
    `(let ,g ,x
       (or ,@(list-map (fn (x) `(is ,g ,x)) xs)))))

(macro (case-let var expr &rest args)
  (let ex (afn (args)
            (if (null? (cdr args))
                (car args)
                `(if (is ,var ,(car args))
                     ,(cadr args)
                     ,(self (cddr args)))))
    `(let ,var ,expr
       ,(ex args))))

(macro (case expr &rest args)
  (w/uniq (g)
    `(case-let ,g ,expr ,@args)))

(def (reduce f x0 xs)
  (if (null? xs)
      x0
      (reduce f (f x0 (car xs)) (cdr xs))))

(def (best f xs)
  (unless (null? xs)
    (reduce (fn (a b) (if (f a b) a b)) (car xs) (cdr xs))))

(def (min &rest xs) (best < xs))
(def (max &rest xs) (best > xs))

(def (neg f) (fn (x) (not (f x))))

(def (capacity x)
  (if (vector? x) (vector-capacity x)
      (bytes? x)  (bytevector-capacity x)
      (string? x) (string-capacity x)))

(def (push-back x value)
  (if (vector? x) (vector-push-back x value)
      (bytes? x)  (bytevector-push-back x value)
      (string? x) (string-push-back x value)))

(macro (accumulate-to-string acc-fn &rest body)
  (w/uniq (gs)
    `(withs (,gs (make-adjustable-string)
             ,acc-fn (fn (c) (string-push-back ,gs c)))
       ,@body
       ,gs)))

(macro (accumulate-to-vector acc-fn &rest body)
  (w/uniq (gv)
    `(withs (,gv (make-adjustable-vector)
             ,acc-fn (fn (c) (vector-push-back ,gv c)))
       ,@body
       ,gv)))

(macro (accumulate-to-dict acc-fn &rest body)
  (w/uniq (gd)
    `(withs (,gd (make-dict)
             ,acc-fn (fn (k v) (dict-set ,gd k v)))
       ,@body
       ,gd)))

(macro (for x xs &rest body)
  (if (symbol? x)        `(for-each ,xs (fn (,x) ,@body))
      (pair? x)          (w/uniq (g)
                           `(for-each ,xs (fn (,g) (let ,x ,g ,@body))))
                         (error "Can't destructure " x)))

(def (append x &rest xs)
  (if (string? x) (apply string-append (cons x xs))
      (list? x)   (apply list-append (cons x xs))
      (vector? x) (apply vector-append (cons x xs))))

(macro (accumulate-reversed acc-fn &rest body)
  (w/uniq (gl)
    `(withs (,gl nil
             ,acc-fn (fn (x) (push x ,gl)))
       ,@body
       ,gl)))

(macro (accumulate acc-fn &rest body)
  `(reverse (accumulate-reversed ,acc-fn ,@body)))

(def (less-than n) (fn (x) (< x n)))
(def (more-than n) (fn (x) (> x n)))

(def (dict &rest content)
  (accumulate-to-dict acc
    ((afn (xs)
       (if (null? xs)       nil
           (null? (cdr xs)) (acc (car xs) nil)
                            (do (acc (car xs) (cadr xs))
                                (self (cddr xs)))))
      content)))

(def (read-line &opt s)
  (if (peek-char s)
    (accumulate-to-string acc
      (whiler c (read-char s) (not (in c nil #\newline))
        (acc c)))))

(def (whitespace c)
  (or (is c #\space)
      (is c #\tab)
      (is c #\newline)
      (is c #\return)))

(def (skip-space &opt s)
  (whiler c (peek-char s) (whitespace c)
    (read-char s)))

(macro (with-input-from-string var str &rest body)
  `(let ,var (open-input-string ,str)
     ,@body))

(macro (with-input-from-file var path &rest body)
  `(let ,var (open-input-file ,path)
     (after (do ,@body) (close ,var))))

(def (atom-delimiter? c)
  (or (whitespace c)
      (in c #\) #\( #\[ #\] #\{ #\})))

(def (error msg &rest rest)
  (apply println (cons msg rest))
  (throw 'read-error))

(def (read-delimited-list d s)
  ((afn (rs)
     (case (skip-space s)
       nil (error "Expected " d)
       d   (do (read-char s) (reverse rs))
           (self (cons (read s true) rs))))
   nil))

(w/uniq (eof)
  (def (eof? x) (is x eof))

  (def (read-atom &opt s)
    (if (skip-space s)
      (let str (accumulate-to-string acc
                 (whiler c (peek-char s) (not (or (null? c) (atom-delimiter? c)))
                   (acc (read-char s))))
        (with-input-from-string ss str
          (cl-read ss)))
      eof))

  (def (read &opt s error-on-eof)
    (case-let c (skip-space s)
      nil (if error-on-eof (error "Unexpected EOF.") eof)
      #\( (do (read-char s) (read-delimited-list #\) s))
      #\[ (do (read-char s) (cons 'vector (read-delimited-list #\] s)))
      #\{ (do (read-char s) (cons 'dict (read-delimited-list #\} s)))
      #\' (do (read-char s) (list 'quote (read s true)))
      #\` (do (read-char s) (list 'quasiquote (read s true)))
      #\, (do (read-char s)
              (if (is (peek-char s) #\@)
                  (do (read-char s)
                      (list 'unquote-splicing (read s true)))
                  (list 'unquote (read s true))))
          (if (is c #\")
              (cl-read s eof)
              (read-atom s)))))

(def (load path)
  (with-input-from-file f path
    (whiler e (read f) (not (eof? e))
      (eval e))))

(load "math.lk")
(load "seq.lk")
(load "records.lk")
(load "strings.lk")
(load "algorithms.lk")
(load "sys.lk")
(load "sockets.lk")


(def repl-prompt "ztalk> ")

(def (print-repl-prompt)
  (print repl-prompt)
  (flush))

(def (repl)
  (whiler e (do (print-repl-prompt) (read stdin)) (not (eof? e))
    (println (eval e))))

(repl)
